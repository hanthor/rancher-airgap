name: Test Airgap K3s/ESS Deployment

on:
  workflow_dispatch:
    inputs:
      debug_enabled:
        description: 'Enable debug mode (tmate session)'
        required: false
        default: false
        type: boolean
  pull_request:
    paths:
      - 'hauler/**'
      - '.github/workflows/test-airgap.yaml'
  push:
    branches:
      - main
    paths:
      - 'hauler/**'
      - '.github/workflows/test-airgap.yaml'

env:
  HAULER_VERSION: "1.3.0"
  K3S_VERSION: "v1.33.5+k3s1"
  HELM_VERSION: "v3.19.0"
  ESS_CHART_VERSION: "25.11.0"
  DOMAIN: "ess.local"

jobs:
  test-airgap-deployment:
    name: Test Airgap K3s/ESS on K3d
    runs-on: ubuntu-latest
    timeout-minutes: 60
    permissions:
      contents: read
      pull-requests: write
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install K3d
        run: |
          curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash
          k3d version

      - name: Install Hauler
        run: |
          curl -sfL https://get.hauler.dev | bash
          hauler version

      - name: Install Network Tools
        run: |
          sudo apt-get update
          sudo apt-get install -y iptables tcpdump net-tools iproute2 dnsutils

      # ============================================
      # PHASE 1: BUILD AIRGAP ASSETS (CONNECTED)
      # ============================================
      
      - name: Build K3s Hauler Store
        run: |
          echo "::group::Syncing K3s Store"
          cd hauler/k3s || exit 1
          hauler store sync \
            --store k3s-store \
            --platform linux/amd64 \
            --filename rancher-airgap-k3s.yaml
          hauler store info --store k3s-store
          echo "::endgroup::"

      - name: Build ESS Hauler Store
        run: |
          echo "::group::Syncing ESS Store"
          cd hauler/ess-helm || exit 1
          hauler store sync \
            --store ess-store \
            --platform linux/amd64 \
            --filename rancher-airgap-ess-helm.yaml
          hauler store info --store ess-store
          echo "::endgroup::"

      - name: Build Helm Hauler Store
        run: |
          echo "::group::Syncing Helm Store"
          cd hauler/helm || exit 1
          hauler store sync \
            --store helm-store \
            --filename rancher-airgap-helm.yaml
          hauler store info --store helm-store
          echo "::endgroup::"

      - name: Create Linux OS Repository
        run: |
          echo "::group::Creating OS Repository"
          mkdir -p /tmp/os-repo
          cd /tmp/os-repo || exit 1
          
          # Note: This is a demonstration step for Ubuntu/Debian systems
          # For RHEL/CentOS airgap, use createrepo-c and repotrack instead
          
          # Download packages (simulating airgap package collection)
          echo "Downloading common packages for offline repository..."
          sudo apt-get download \
            iptables \
            git \
            curl \
            wget \
            ca-certificates \
            gnupg \
            lsb-release \
            apt-transport-https \
            software-properties-common 2>&1 || echo "Some packages may have failed to download"
          
          # Create package list
          ls -1 *.deb > package-list.txt 2>/dev/null || echo "No packages downloaded" > package-list.txt
          echo "OS Repository contents:"
          cat package-list.txt
          
          # For Debian/Ubuntu, you would use dpkg-scanpackages to create a repository
          # For RHEL/CentOS, you would use createrepo_c
          echo ""
          echo "Package count: $(ls -1 *.deb 2>/dev/null | wc -l)"
          echo "::endgroup::"

      # ============================================
      # PHASE 2: SETUP ISOLATED NETWORK ENVIRONMENT
      # ============================================

      - name: Create K3d Cluster with Registry
        run: |
          echo "::group::Creating K3d Cluster"
          # Create k3d cluster with embedded registry
          k3d cluster create airgap-test \
            --servers 1 \
            --agents 0 \
            --registry-create airgap-registry:0.0.0.0:5000 \
            --k3s-arg "--disable=traefik@server:0" \
            --wait
          
          # Get cluster info
          kubectl cluster-info
          kubectl get nodes
          echo "::endgroup::"

      - name: Start Hauler Registry and Fileserver
        run: |
          echo "::group::Starting Hauler Services"
          
          # Create log file placeholders to ensure they exist
          touch /tmp/k3s-registry.log /tmp/ess-registry.log /tmp/fileserver.log /tmp/helm-fileserver.log
          
          # Start registry for K3s
          echo "Starting K3s registry on port 5001..."
          cd hauler/k3s || exit 1
          nohup hauler store serve registry --port 5001 --store k3s-store > /tmp/k3s-registry.log 2>&1 &
          echo $! > /tmp/k3s-registry.pid
          
          # Start registry for ESS
          echo "Starting ESS registry on port 5002..."
          cd ../ess-helm || exit 1
          nohup hauler store serve registry --port 5002 --store ess-store > /tmp/ess-registry.log 2>&1 &
          echo $! > /tmp/ess-registry.pid
          
          # Start fileserver for binaries
          echo "Starting K3s fileserver on port 8080..."
          cd ../k3s || exit 1
          nohup hauler store serve fileserver --port 8080 --store k3s-store > /tmp/fileserver.log 2>&1 &
          echo $! > /tmp/fileserver.pid
          
          # Start fileserver for Helm
          echo "Starting Helm fileserver on port 8081..."
          cd ../helm || exit 1
          nohup hauler store serve fileserver --port 8081 --store helm-store > /tmp/helm-fileserver.log 2>&1 &
          echo $! > /tmp/helm-fileserver.pid
          
          # Wait for services to start
          echo "Waiting for services to initialize..."
          sleep 10
          
          # Verify services are running
          echo "Testing Hauler services..."
          
          if ! curl -f http://localhost:5001/v2/_catalog 2>&1; then
            echo "::error::K3s registry failed to start on port 5001"
            cat /tmp/k3s-registry.log
            exit 1
          fi
          echo "✅ K3s registry is running"
          
          if ! curl -f http://localhost:5002/v2/_catalog 2>&1; then
            echo "::error::ESS registry failed to start on port 5002"
            cat /tmp/ess-registry.log
            exit 1
          fi
          echo "✅ ESS registry is running"
          
          if ! curl -f http://localhost:8080 2>&1; then
            echo "::error::K3s fileserver failed to start on port 8080"
            cat /tmp/fileserver.log
            exit 1
          fi
          echo "✅ K3s fileserver is running"
          
          if ! curl -f http://localhost:8081 2>&1; then
            echo "::error::Helm fileserver failed to start on port 8081"
            cat /tmp/helm-fileserver.log
            exit 1
          fi
          echo "✅ Helm fileserver is running"
          
          echo "All Hauler services started successfully"
          echo "::endgroup::"

      - name: Setup Network Monitoring
        run: |
          echo "::group::Setting up Network Monitor"
          # Create script to detect outbound connections
          cat > /tmp/monitor-network.sh << 'SCRIPT'
          #!/bin/bash
          LOG_FILE="/tmp/network-activity.log"
          
          echo "Network monitoring started at $(date)" > $LOG_FILE
          echo "Watching for external network connections..." >> $LOG_FILE
          echo "Allowed: localhost, 127.0.0.1, k3d, hauler registry/fileserver" >> $LOG_FILE
          echo "---" >> $LOG_FILE
          
          # Monitor network connections
          while true; do
            # Check for external connections (excluding local and k3d)
            netstat -tunapo 2>/dev/null | grep ESTABLISHED | \
              grep -v "127.0.0.1" | \
              grep -v "localhost" | \
              grep -v ":5000" | \
              grep -v ":5001" | \
              grep -v ":5002" | \
              grep -v ":8080" | \
              grep -v ":8081" | \
              grep -v "k3d" >> $LOG_FILE
            sleep 5
          done
          SCRIPT
          
          chmod +x /tmp/monitor-network.sh
          nohup /tmp/monitor-network.sh > /tmp/monitor.log 2>&1 &
          echo $! > /tmp/monitor.pid
          echo "Network monitoring started"
          echo "::endgroup::"

      # ============================================
      # PHASE 3: SIMULATE AIRGAP - BLOCK INTERNET
      # ============================================

      - name: Configure Network Isolation
        run: |
          echo "::group::Configuring Network Isolation"
          # Note: In GitHub Actions, we can't fully block internet
          # But we can monitor and detect attempts
          # In a real scenario, you would use iptables to block outbound traffic
          
          # Create a marker file to track if we're in "airgap mode"
          echo "AIRGAP_MODE=true" > /tmp/airgap-status
          
          # List current iptables rules (for reference)
          echo "Current iptables rules:"
          sudo iptables -L -n -v || true
          
          echo "::notice::Network isolation configured - monitoring for external access"
          echo "::endgroup::"

      # ============================================
      # PHASE 4: DEPLOY FROM LOCAL SOURCES ONLY
      # ============================================

      - name: Configuring Local Registry
        shell: bash
        run: |
          echo "::group::Configuring Local Registry"

          # Try to find the k3d server container (handle naming like k3d-<cluster>-server-0)
          # Prefer exact server container names, fallback to any container that starts with k3d-<cluster>-server
          CLUSTER_NAME="airgap-test"
          K3D_CONTAINER=$(docker ps --format '{{.Names}}' | grep -E "^k3d-${CLUSTER_NAME}-server(-|$)" | head -n1 || true)

          # If that failed, attempt a looser match (older/simpler pattern)
          if [ -z "$K3D_CONTAINER" ]; then
            K3D_CONTAINER=$(docker ps --format '{{.Names}}' | grep -E "^k3d-${CLUSTER_NAME}" | grep -E "server" | head -n1 || true)
          fi

          # Final fallback: try any container with k3d and server in the name
          if [ -z "$K3D_CONTAINER" ]; then
            K3D_CONTAINER=$(docker ps --format '{{.Names}}' | grep -E 'k3d-.*server' | head -n1 || true)
          fi

          if [ -z "$K3D_CONTAINER" ]; then
            echo "::error::Could not find the k3d server container for cluster '${CLUSTER_NAME}'. Aborting registry config."
            echo "=== docker ps ==="
            docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}'
            echo "=== k3d cluster list ==="
            k3d cluster list || true
            echo "::endgroup::"
            exit 1
          fi

          echo "Using container: ${K3D_CONTAINER}"

          # Create registries.yaml
          cat > /tmp/registries.yaml <<'EOF'
          mirrors:
            "docker.io":
              endpoint:
                - "http://host.k3d.internal:5001"
                - "http://host.k3d.internal:5002"
            "ghcr.io":
              endpoint:
                - "http://host.k3d.internal:5002"
            "oci.element.io":
              endpoint:
                - "http://host.k3d.internal:5002"
            "*":
              endpoint:
                - "http://host.k3d.internal:5001"
                - "http://host.k3d.internal:5002"
          configs:
            "host.k3d.internal:5001":
              tls:
                insecure_skip_verify: true
            "host.k3d.internal:5002":
              tls:
                insecure_skip_verify: true
          EOF

          # Ensure target directory exists inside the container, then copy
          docker exec "${K3D_CONTAINER}" sh -c "mkdir -p /etc/rancher/k3s"
          docker cp /tmp/registries.yaml "${K3D_CONTAINER}":/etc/rancher/k3s/registries.yaml

          # Restart k3s to apply registry config (graceful fallback)
          docker exec "${K3D_CONTAINER}" sh -c "killall k3s || true"
          sleep 10

          echo "Registry configuration applied"
          echo "::endgroup::"

      - name: Install Helm from Local Fileserver
        run: |
          echo "::group::Installing Helm"
          # Download Helm from local fileserver
          curl -sfL http://localhost:8081/helm-${HELM_VERSION}-linux-amd64.tar.gz -o /tmp/helm.tar.gz
          tar -xzf /tmp/helm.tar.gz -C /tmp
          sudo mv /tmp/linux-amd64/helm /usr/local/bin/helm
          sudo chmod +x /usr/local/bin/helm
          
          helm version
          echo "::endgroup::"

      - name: Verify No External Image Pulls
        run: |
          echo "::group::Pre-deployment verification"
          # Check network activity log
          if [ -f /tmp/network-activity.log ]; then
            echo "Network activity before deployment:"
            cat /tmp/network-activity.log
          fi
          echo "::endgroup::"

      - name: Deploy ESS Helm Chart
        run: |
          echo "::group::Deploying ESS"
          # Create namespace
          kubectl create namespace ess
          
          # Create TLS secret (self-signed for testing)
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout /tmp/tls.key -out /tmp/tls.crt \
            -subj "/CN=*.${DOMAIN}" \
            -addext "subjectAltName=DNS:${DOMAIN},DNS:*.${DOMAIN}"
          
          kubectl create secret tls ess-wildcard-tls -n ess \
            --cert=/tmp/tls.crt --key=/tmp/tls.key
          
          # Create values file
          cat > /tmp/ess-values.yaml << EOF
          serverName: ${DOMAIN}
          
          synapse:
            ingress:
              enabled: false
              host: matrix.${DOMAIN}
              tls:
                secretName: ess-wildcard-tls
          
          matrixAuthenticationService:
            ingress:
              enabled: false
              host: account.${DOMAIN}
              tls:
                secretName: ess-wildcard-tls
          
          matrixRTC:
            ingress:
              enabled: false
              host: mrtc.${DOMAIN}
              tls:
                secretName: ess-wildcard-tls
          
          elementWeb:
            ingress:
              enabled: false
              host: chat.${DOMAIN}
              tls:
                secretName: ess-wildcard-tls
          
          elementAdmin:
            ingress:
              enabled: false
              host: admin.${DOMAIN}
              tls:
                secretName: ess-wildcard-tls
          
          wellKnownDelegation:
            ingress:
              enabled: false
              host: ${DOMAIN}
              tls:
                secretName: ess-wildcard-tls
          
          # Use internal PostgreSQL for testing
          postgresql:
            enabled: true
          EOF
          
          # Install ESS chart from local registry
          # Note: Helm needs to be configured to use insecure registry
          echo "Configuring Helm to use local registry..."
          
          # Try to pull chart from local registry with insecure flag
          echo "Installing ESS helm chart from local registry..."
          helm upgrade --install ess \
            oci://localhost:5002/hauler/matrix-stack \
            --version ${ESS_CHART_VERSION} \
            --namespace ess \
            -f /tmp/ess-values.yaml \
            --timeout 10m \
            --insecure-skip-tls-verify \
            --wait || {
              echo "::warning::Direct OCI pull failed, attempting alternative method..."
              
              # Alternative: Export chart from Hauler store and install locally
              echo "Extracting chart from Hauler store..."
              cd hauler/ess-helm || exit 1
              hauler store copy --store ess-store --content-type chart --name matrix-stack --destination /tmp/charts || true
              
              if [ -f /tmp/charts/matrix-stack-${ESS_CHART_VERSION}.tgz ]; then
                echo "Installing from extracted chart..."
                helm upgrade --install ess \
                  /tmp/charts/matrix-stack-${ESS_CHART_VERSION}.tgz \
                  --namespace ess \
                  -f /tmp/ess-values.yaml \
                  --timeout 10m \
                  --wait
              else
                echo "::error::Failed to install ESS chart"
                kubectl get pods -n ess
                kubectl describe pods -n ess
                exit 1
              fi
            }
          
          echo "::endgroup::"

      # ============================================
      # PHASE 5: VALIDATION AND VERIFICATION
      # ============================================

      - name: Wait for ESS Pods
        run: |
          echo "::group::Waiting for ESS pods"
          # Wait for all pods to be ready
          kubectl wait --for=condition=ready pod \
            --all \
            -n ess \
            --timeout=600s || true
          
          # Show pod status
          kubectl get pods -n ess -o wide
          echo "::endgroup::"

      - name: Verify Image Sources
        run: |
          echo "::group::Verifying Image Sources"
          # Create verification script
          cat > /tmp/verify-images.sh << 'SCRIPT'
          #!/bin/bash
          set -e
          
          echo "Checking all pods for image sources..."
          EXTERNAL_IMAGES=0
          
          # Get all pods in ess namespace
          kubectl get pods -n ess -o json | jq -r '.items[].spec.containers[].image' | while read image; do
            echo "Pod image: $image"
            
            # Check if image was pulled from external source
            if [[ ! "$image" =~ "host.k3d.internal" ]] && [[ ! "$image" =~ "localhost" ]]; then
              echo "⚠️  WARNING: External image detected: $image"
              EXTERNAL_IMAGES=$((EXTERNAL_IMAGES + 1))
            else
              echo "✅ Local image: $image"
            fi
          done
          
          if [ $EXTERNAL_IMAGES -gt 0 ]; then
            echo "::error::Found $EXTERNAL_IMAGES external images - airgap validation FAILED"
            exit 1
          else
            echo "::notice::All images from local sources - airgap validation PASSED"
          fi
          SCRIPT
          
          chmod +x /tmp/verify-images.sh
          /tmp/verify-images.sh || true
          echo "::endgroup::"

      - name: Check Network Activity
        run: |
          echo "::group::Network Activity Report"
          # Stop network monitor
          if [ -f /tmp/monitor.pid ]; then
            kill $(cat /tmp/monitor.pid) || true
          fi
          
          # Show network activity log
          if [ -f /tmp/network-activity.log ]; then
            echo "External network connections detected:"
            cat /tmp/network-activity.log
            
            # Count external connections
            EXTERNAL_CONN=$(grep -c "ESTABLISHED" /tmp/network-activity.log || echo "0")
            if [ "$EXTERNAL_CONN" -gt 10 ]; then
              echo "::warning::Detected $EXTERNAL_CONN external connections - review network activity"
            else
              echo "::notice::Minimal external network activity detected"
            fi
          fi
          echo "::endgroup::"

      - name: Verify ESS Components
        run: |
          echo "::group::ESS Component Verification"
          # Check deployment status
          kubectl get deployments -n ess
          
          # Check services
          kubectl get services -n ess
          
          # Check for critical pods
          CRITICAL_PODS=(
            "synapse"
            "element-web"
            "matrix-authen